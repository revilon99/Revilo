package cass.oli.pong;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferStrategy;
import java.util.ArrayList;

import cass.oli.revilo.Game;
import cass.oli.revilo.Revilo;

public class Pong extends Game implements Runnable{
	private static final long serialVersionUID = 1L;
	
	public static final float EPSILON_TIME = 1e-2f; //Threshold for zero time
	public BoxContainer box;
	public ArrayList<GameObject> objects = new ArrayList<GameObject>();
	public ArrayList<GameObject> addObjects = new ArrayList<GameObject>();
	public ArrayList<GameObject> removeObjects = new ArrayList<GameObject>();
	private int objID = 0;
	private final int spriteRatio = 10;
	
	public Pong(Revilo revilo) {
		super(revilo);
		this.setSize(WIDTH, HEIGHT);
		box = new BoxContainer(0, 0, WIDTH, HEIGHT);
	}
	public Pong() {
		this.setSize(WIDTH, HEIGHT);
		box = new BoxContainer(0, 0, WIDTH, HEIGHT);
	}
	
	public void tap(int x, int y) {
		//Organise top down in terms of layer height
		//return after each function
		
		//Pause Button
		if(x > width - 60 && x < width - 10 && y > 10 && y < 70) {
			paused = !paused;
			return;
		}
		if(paused) {
			int nButtons = 1;
			if(revilo != null) nButtons = 2;
			int spriteWidth = (int) Math.round(width / spriteRatio); 
			int offset = (int) Math.round((height - spriteWidth * nButtons)/(nButtons+1));
			
			//Reset
			if(		x > (width - spriteWidth)/2 && x < (width + spriteWidth)/2 &&
					y > offset && y < offset + spriteWidth) {
				removeObjects.addAll(objects);
				paused = false;
				return;
			}
			//Home
			if(		x > (width - spriteWidth)/2 && x < (width + spriteWidth)/2 &&
					y > 2*offset + spriteWidth && y < 2*(offset + spriteWidth) && revilo != null) {
				revilo.setGame(revilo.games.get(0));
			}
		}else {
			//Remove Ball
			for(GameObject object : objects){
				if(object.shape == Shape.Circle) {
					Ball ball = (Ball) object;
					double xDist = x - ball.x;
		            double yDist = y - ball.y;
		            double dist = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));
		            if(dist < ball.radius) {
		    			//ball.print();
		                removeBall(ball);
		                return;
		            }
				}
			}
			
			//Add Ball
			addBall(new Ball(x, y, objID));
			objID++;	
		}
	}
	
	public void tick() {
		float timeLeft = 1.0f;
		
		//Synchronises adding and removing objects
		for(GameObject object : addObjects) {
			boolean add = true;
			
			switch(object.shape) {
			case Circle:
				Ball nBall = (Ball) object;
				if(        nBall.x - nBall.radius < 0
						|| nBall.x + nBall.radius > width
						|| nBall.y - nBall.radius < 0
						|| nBall.y + nBall.radius > height) {
					add = false;
					break;
				}
				for(GameObject exist : objects) {
					switch(exist.shape) {
					case Circle:
						Ball ball = (Ball) exist;
						if(ball.ballCollision(nBall)) add = false;
						break;
					default:
						break;
					
					}
				}
				break;
			default:
				break;
			
			}
			
			if(add) objects.add(object);			
		}
		addObjects.clear();
		
		for(GameObject object : removeObjects) {
			objects.remove(object);
		}
		removeObjects.clear();
		
		do {
			float tMin = timeLeft;
			
			//Object-Object Collision
			for(int i = 0; i < objects.size(); i++) {
				for(int j = 0; j < objects.size(); j++) {
					if(i < j) {
						objects.get(i).intersect(objects.get(j), tMin);
						if(objects.get(i).earliestCollisionResponse.t < tMin) 
							tMin = objects.get(i).earliestCollisionResponse.t;
					}
				}
			}
			
			//Object-Wall Collision
			for(GameObject object : objects) {
				object.intersect(box, timeLeft);
				if(object.earliestCollisionResponse.t < tMin) {
					tMin = object.earliestCollisionResponse.t;
				}
			}
			//Move
			for(GameObject object : objects) object.update(tMin);
			
			if(tMin > 0.05) { //Do Not Display Small Changes
				render();
				try {
					Thread.sleep((long)(1000L / TARGET_FPS * tMin));
				}catch(InterruptedException e) {}
			}
			timeLeft -= tMin;
		}while(timeLeft > EPSILON_TIME);
	}
	
	public void render() {
		BufferStrategy bs = this.getBufferStrategy();
		if(bs == null){
			this.createBufferStrategy(3);
			return;
		}
		
		Graphics g1 = bs.getDrawGraphics();
		Graphics2D g = (Graphics2D) g1;
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, // Anti-alias!
		        RenderingHints.VALUE_ANTIALIAS_ON);

		//Background
		g.setColor(Color.black);
		g.fillRect(0, 0, width, height);
				
		//Game Objects
		for(GameObject object : objects) {
			object.render(g);
		}
		
		//Pause Button
		g.setColor(Color.white);
		if(!paused) {
			g.fillRect(width - 60, 10, 20, 60);
			g.fillRect(width - 30, 10, 20, 60);
		}else {
			g.setColor(new Color(0, 0, 0, 150));
			g.fillRect(0, 0, width, height);
			g.setColor(Color.white);
			
			int nButtons = 1;
			if(revilo != null) nButtons = 2;
			int spriteWidth = (int) Math.round(width / spriteRatio); 
			int offset = (int) Math.round((height - spriteWidth * nButtons)/(nButtons+1));
			
			g.drawImage(sprites[1], (width - spriteWidth)/2, offset, spriteWidth, spriteWidth, null);
			if(revilo != null) g.drawImage(sprites[0], (width - spriteWidth)/2, offset + spriteWidth + offset, spriteWidth, spriteWidth, null);
			
			int[] xTri = {width- 60, width - 10, width - 60};
			int[] yTri = {10, 40, 70};
			g.fillPolygon(xTri, yTri, 3);
		}
		
		g.dispose();
		bs.show();
	}
	
	@Override
	public void resize() {
		this.width = getWidth();
		this.height = getHeight();
		this.box = new BoxContainer(0, 0, width, height);
	}
	
	public void addBall(Ball ball) {
		addObjects.add(ball);
	}
	public void removeBall(Ball ball) {
		removeObjects.add(ball);
	}

	@Override
	public void leftClick(int x, int y) {
		tap(x, y);		
	}

	@Override
	public void rightClick(int x, int y) {
		//Do Nothing
	}
	@Override
	public void dragTo(int x, int y) {
		//do nothing
	}
}
