!SESSION 2019-09-04 08:10:18.879 -----------------------------------------------
eclipse.buildId=4.12.0.I20190605-1800
java.version=12.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.core 1 0 2019-09-04 08:11:10.019
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.egit.ui 2 0 2019-09-04 08:11:22.823
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\olica'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-09-04 08:13:37.947 -----------------------------------------------
eclipse.buildId=4.12.0.I20190605-1800
java.version=12.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.core 1 0 2019-09-04 08:13:47.219
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.egit.ui 2 0 2019-09-04 08:14:05.502
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\olica'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2019-09-04 11:10:16.993
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cass.oli.mandelbrot;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;

import cass.oli.revilo.Game;
import cass.oli.revilo.Revilo;

public class Mandelbrot extends Game {
	private static final long serialVersionUID = 1L;
	private BufferedImage image = null;
	/**
	 * see http://java.rubikscube.info/
	 */
	private final int default_max = 6;
	private final int absolute_max = 12;
	private int current_max = 6;
	private Color[][] colors;
	private long lastRender = 0;
	private static final int[][][] colpal = {
		{ {0, 10, 20}, {50, 100, 240}, {20, 3, 26}, {230, 60, 20},
		{25, 10, 9}, {230, 170, 0}, {20, 40, 10}, {0, 100, 0},
		{5, 10, 10}, {210, 70, 30}, {90, 0, 50}, {180, 90, 120},
		{0, 20, 40}, {30, 70, 200} },
		{ {70, 0, 20}, {100, 0, 100}, {255, 0, 0}, {255, 200, 0} },
		{ {40, 70, 10}, {40, 170, 10}, {100, 255, 70}, {255, 255, 255} },
		{ {0, 0, 0}, {0, 0, 255}, {0, 255, 255}, {255, 255, 255}, {0, 128, 255} },
		{ {0, 0, 0}, {255, 255, 255}, {128, 128, 128} },
	};
	private int pal = 0;
	private static final int[][] rows = {
		{ 0, 16,  8}, { 8, 16,  8}, 
		{ 4, 16,  4}, {12, 16,  4},
		{ 2, 16,  2}, {10, 16,  2}, 
		{ 6, 16,  2}, {14, 16,  2}, 
		{ 1, 16,  1}, { 9, 16,  1},
		{ 5, 16,  1}, {13, 16,  1},
		{ 3, 16,  1}, {11, 16,  1},
		{ 7, 16,  1}, {15, 16,  1}};

	private boolean smooth = true;
	private boolean antialias = true;
	private double viewX = 0.0;
	private double viewY = 0.0;
	private double zoom = 1.0;
	private boolean finished = 

	
	public Mandelbrot(Revilo revilo) {
		super(revilo);
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	public Mandelbrot() {
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	
	public void draw() {
		BufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		System.out.println(width + ", " + height);
		Graphics g = newImage.getGraphics();

		// fractal image drawing
		for (int row = 0; row < rows.length; row++) {
			for (int y = rows[row][0]; y < height; y += rows[row][1]) {
				for (int x = 0; x < width; x++) {
					double r = zoom / Math.min(width, height);
					double dx = 2.5 * (x * r + viewX) - 2;
					double dy = 1.25 - 2.5 * (y * r + viewY);
					Color color = color(dx, dy);
					if (antialias) {
						Color c1 = color(dx - 0.25 * r, dy - 0.25 * r);
						Color c2 = color(dx + 0.25 * r, dy - 0.25 * r);
						Color c3 = color(dx + 0.25 * r, dy + 0.25 * r);
						Color c4 = color(dx - 0.25 * r, dy + 0.25 * r);
						int red = (color.getRed() + c1.getRed() + c2.getRed() + c3.getRed() + c4.getRed()) / 5;
						int green = (color.getGreen() + c1.getGreen() + c2.getGreen() + c3.getGreen() + c4.getGreen()) / 5;
						int blue = (color.getBlue() + c1.getBlue() + c2.getBlue() + c3.getBlue() + c4.getBlue()) / 5;
						color = new Color(red, green, blue);
					}
					g.setColor(color);
					g.fillRect(x, y - rows[row][2] / 2, 1, rows[row][2]);
				}
			}
		}
		g.dispose();
		image = newImage;
	}
	
	public void update() {
		current_max = default_max;
		lastRender = System.currentTimeMillis();
		draw();
	}
	
	public void zoomIn(double scale) {
		viewX += (double) zoom*(scale - 1)/2;
		viewY += (double) zoom*(scale - 1)/2;
		zoom /= scale;
		
		update();
	}
	public void zoomOut(double scale) {
		viewX -= (double) zoom*(scale - 1)/2;
		viewY -= (double) zoom*(scale - 1)/2;
		zoom *= scale;
		update();
	}

	public void dragTo(int x, int y) {
		int dx = Math.abs(x - mouseX);
		int dy = Math.abs(y - mouseY);
		if(dx == 0 || dy == 0) return;
		double scale;
		if(dx < dy) scale = width / dx;
		else scale = height / dy;
		
		viewX += 2*zoom*mouseX/width;
		viewY += zoom*mouseY/height;
		
		zoom /= scale;
		update();
	}
	public void newPallette() {
		pal = (pal + 1) % colpal.length;
		update();
	}
	public void reset() {
		viewX = 0;
		viewY = 0;
		zoom = 1.0;
		update();
	}
	
	// Computes a colour for a given point
	private Color color(double x, double y) {
		int count = mandel(x, y);
		int palSize = colors[pal].length;
		Color color = colors[pal][count / 256 % palSize];
		if (smooth) {
			Color color2 = colors[pal][(count / 256 + palSize - 1) % palSize];
			int k1 = count % 256;
			int k2 = 255 - k1;
			int red = (k1 * color.getRed() + k2 * color2.getRed()) / 255;
			int green = (k1 * color.getGreen() + k2 * color2.getGreen()) / 255;
			int blue = (k1 * color.getBlue() + k2 * color2.getBlue()) / 255;
			color = new Color(red, green, blue);
		}
		return color;
	}
	
	private int mandel(double pRe, double pIm) {
		double zRe = 0;
		double zIm = 0;
		double zRe2 = zRe * zRe;
		double zIm2 = zIm * zIm;
		double zM2 = 0.0;
		int count = 0;
		int max = (int) Math.pow(2, current_max);
		while (zRe2 + zIm2 < 4.0 && count < max) {
			zM2 = zRe2 + zIm2;
			zIm = 2.0 * zRe * zIm + pIm;
			zRe = zRe2 - zIm2 + pRe;
			zRe2 = zRe * zRe;
			zIm2 = zIm * zIm;
			count++;
		}
		if (count == 0 || count == max) return 0;
		// transition smoothing
		zM2 += 0.000000001;
		return 256 * count + (int)(255.0 * Math.log(4 / zM2) / Math.log((zRe2 + zIm2) / zM2));
	}

	@Override
	public void leftClick(int x, int y) {
		//do nothing
	}

	@Override
	public void rightClick(int x, int y) {
		reset();
	}

	@Override
	protected void tick() {
		long timeSinceLastRender = System.currentTimeMillis() - lastRender;
		if(timeSinceLastRender > 4000) {
			if(current_max < absolute_max) current_max++;
			lastRender = System.currentTimeMillis();
			draw();
		}
	}

	@Override
	protected void render() {
		BufferStrategy bs = this.getBufferStrategy();
		if(bs == null){
			this.createBufferStrategy(3);
			return;
		}
		
		Graphics g1 = bs.getDrawGraphics();
		Graphics2D g = (Graphics2D) g1;
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, // Anti-alias!
		        RenderingHints.VALUE_ANTIALIAS_ON);
		g.setColor(Color.black);
		if(image == null) g.fillRect(0, 0, width, height);
		else g.drawImage(image, null, 0, 0);
		
		if(dragging) {
			g.setColor(Color.white);
			double dx = Math.abs(dragX - mouseX);
			double dy = Math.abs(dragY - mouseY);
			if(dx != 0 && dy != 0) {
				double scale;
				if(dx < dy) scale = width / dx;
				else scale = height / dy;
				g.drawRect(mouseX, mouseY, (int) Math.round(width/scale), (int) Math.round(height/scale));
			}
		}
		g.dispose();
		bs.show();
	}
	
	@Override
	public void resize() {
		width = this.getWidth();
		height = this.getHeight();
		update();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-09-04 11:10:16.997
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-09-04 11:10:17.000
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-09-04 11:26:32.338
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cass.oli.mandelbrot;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;

import cass.oli.revilo.Game;
import cass.oli.revilo.Revilo;

public class Mandelbrot extends Game {
	private static final long serialVersionUID = 1L;
	private BufferedImage image = null;
	/**
	 * see http://java.rubikscube.info/
	 */
	private final int default_max = 6;
	private final int absolute_max = 12;
	private int current_max = 6;
	private Color[][] colors;
	private long lastRender = 0;
	private static final int[][][] colpal = {
		{ {0, 10, 20}, {50, 100, 240}, {20, 3, 26}, {230, 60, 20},
		{25, 10, 9}, {230, 170, 0}, {20, 40, 10}, {0, 100, 0},
		{5, 10, 10}, {210, 70, 30}, {90, 0, 50}, {180, 90, 120},
		{0, 20, 40}, {30, 70, 200} },
		{ {70, 0, 20}, {100, 0, 100}, {255, 0, 0}, {255, 200, 0} },
		{ {40, 70, 10}, {40, 170, 10}, {100, 255, 70}, {255, 255, 255} },
		{ {0, 0, 0}, {0, 0, 255}, {0, 255, 255}, {255, 255, 255}, {0, 128, 255} },
		{ {0, 0, 0}, {255, 255, 255}, {128, 128, 128} },
	};
	private int pal = 0;
	private static final int[][] rows = {
		{ 0, 16,  8}, { 8, 16,  8}, 
		{ 4, 16,  4}, {12, 16,  4},
		{ 2, 16,  2}, {10, 16,  2}, 
		{ 6, 16,  2}, {14, 16,  2}, 
		{ 1, 16,  1}, { 9, 16,  1},
		{ 5, 16,  1}, {13, 16,  1},
		{ 3, 16,  1}, {11, 16,  1},
		{ 7, 16,  1}, {15, 16,  1}};

	private boolean smooth = true;
	private boolean antialias = true;
	private double viewX = 0.0;
	private double viewY = 0.0;
	private double zoom = 1.0;
	Thread improve = new Thread() {
		public void run() {
			while(true) {
]				if(current_max < absolute_max) current_max++;
				lastRender = System.currentTimeMillis();
				draw();
			}
		}
	};;

	
	public Mandelbrot(Revilo revilo) {
		super(revilo);
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	public Mandelbrot() {
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	
	public void draw() {
		BufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		Graphics g = newImage.getGraphics();

		// fractal image drawing
		for (int row = 0; row < rows.length; row++) {
			for (int y = rows[row][0]; y < height; y += rows[row][1]) {
				for (int x = 0; x < width; x++) {
					double r = zoom / Math.min(width, height);
					double dx = 2.5 * (x * r + viewX) - 2;
					double dy = 1.25 - 2.5 * (y * r + viewY);
					Color color = color(dx, dy);
					if (antialias) {
						Color c1 = color(dx - 0.25 * r, dy - 0.25 * r);
						Color c2 = color(dx + 0.25 * r, dy - 0.25 * r);
						Color c3 = color(dx + 0.25 * r, dy + 0.25 * r);
						Color c4 = color(dx - 0.25 * r, dy + 0.25 * r);
						int red = (color.getRed() + c1.getRed() + c2.getRed() + c3.getRed() + c4.getRed()) / 5;
						int green = (color.getGreen() + c1.getGreen() + c2.getGreen() + c3.getGreen() + c4.getGreen()) / 5;
						int blue = (color.getBlue() + c1.getBlue() + c2.getBlue() + c3.getBlue() + c4.getBlue()) / 5;
						color = new Color(red, green, blue);
					}
					g.setColor(color);
					g.fillRect(x, y - rows[row][2] / 2, 1, rows[row][2]);
				}
			}
		}
		g.dispose();
		image = newImage;
	}
	
	public void update() {
		current_max = default_max;
		lastRender = System.currentTimeMillis();
		try {
			improve.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		draw();
	}
	
	public void zoomIn(double scale) {
		viewX += (double) zoom*(scale - 1)/2;
		viewY += (double) zoom*(scale - 1)/2;
		zoom /= scale;
		
		update();
	}
	public void zoomOut(double scale) {
		viewX -= (double) zoom*(scale - 1)/2;
		viewY -= (double) zoom*(scale - 1)/2;
		zoom *= scale;
		update();
	}

	public void dragTo(int x, int y) {
		int dx = Math.abs(x - mouseX);
		int dy = Math.abs(y - mouseY);
		if(dx == 0 || dy == 0) return;
		double scale;
		if(dx < dy) scale = width / dx;
		else scale = height / dy;
		
		viewX += 2*zoom*mouseX/width;
		viewY += zoom*mouseY/height;
		
		zoom /= scale;
		update();
	}
	public void newPallette() {
		pal = (pal + 1) % colpal.length;
		update();
	}
	public void reset() {
		viewX = 0;
		viewY = 0;
		zoom = 1.0;
		update();
	}
	
	// Computes a colour for a given point
	private Color color(double x, double y) {
		int count = mandel(x, y);
		int palSize = colors[pal].length;
		Color color = colors[pal][count / 256 % palSize];
		if (smooth) {
			Color color2 = colors[pal][(count / 256 + palSize - 1) % palSize];
			int k1 = count % 256;
			int k2 = 255 - k1;
			int red = (k1 * color.getRed() + k2 * color2.getRed()) / 255;
			int green = (k1 * color.getGreen() + k2 * color2.getGreen()) / 255;
			int blue = (k1 * color.getBlue() + k2 * color2.getBlue()) / 255;
			color = new Color(red, green, blue);
		}
		return color;
	}
	
	private int mandel(double pRe, double pIm) {
		double zRe = 0;
		double zIm = 0;
		double zRe2 = zRe * zRe;
		double zIm2 = zIm * zIm;
		double zM2 = 0.0;
		int count = 0;
		int max = (int) Math.pow(2, current_max);
		while (zRe2 + zIm2 < 4.0 && count < max) {
			zM2 = zRe2 + zIm2;
			zIm = 2.0 * zRe * zIm + pIm;
			zRe = zRe2 - zIm2 + pRe;
			zRe2 = zRe * zRe;
			zIm2 = zIm * zIm;
			count++;
		}
		if (count == 0 || count == max) return 0;
		// transition smoothing
		zM2 += 0.000000001;
		return 256 * count + (int)(255.0 * Math.log(4 / zM2) / Math.log((zRe2 + zIm2) / zM2));
	}

	@Override
	public void leftClick(int x, int y) {
		//do nothing
	}

	@Override
	public void rightClick(int x, int y) {
		reset();
	}

	@Override
	protected void tick() {
		long timeSinceLastRender = System.currentTimeMillis() - lastRender;
		if(timeSinceLastRender > 4000) {
			improve.run();
		}
	}

	@Override
	protected void render() {
		BufferStrategy bs = this.getBufferStrategy();
		if(bs == null){
			this.createBufferStrategy(3);
			return;
		}
		
		Graphics g1 = bs.getDrawGraphics();
		Graphics2D g = (Graphics2D) g1;
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, // Anti-alias!
		        RenderingHints.VALUE_ANTIALIAS_ON);
		g.setColor(Color.black);
		if(image == null) g.fillRect(0, 0, width, height);
		else g.drawImage(image, null, 0, 0);
		
		if(dragging) {
			g.setColor(Color.white);
			double dx = Math.abs(dragX - mouseX);
			double dy = Math.abs(dragY - mouseY);
			if(dx != 0 && dy != 0) {
				double scale;
				if(dx < dy) scale = width / dx;
				else scale = height / dy;
				g.drawRect(mouseX, mouseY, (int) Math.round(width/scale), (int) Math.round(height/scale));
			}
		}
		g.dispose();
		bs.show();
	}
	
	@Override
	public void resize() {
		width = this.getWidth();
		height = this.getHeight();
		update();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-09-04 11:26:32.341
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-09-04 11:26:32.344
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-09-04 11:26:37.367
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cass.oli.mandelbrot;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;

import cass.oli.revilo.Game;
import cass.oli.revilo.Revilo;

public class Mandelbrot extends Game {
	private static final long serialVersionUID = 1L;
	private BufferedImage image = null;
	/**
	 * see http://java.rubikscube.info/
	 */
	private final int default_max = 6;
	private final int absolute_max = 12;
	private int current_max = 6;
	private Color[][] colors;
	private long lastRender = 0;
	private static final int[][][] colpal = {
		{ {0, 10, 20}, {50, 100, 240}, {20, 3, 26}, {230, 60, 20},
		{25, 10, 9}, {230, 170, 0}, {20, 40, 10}, {0, 100, 0},
		{5, 10, 10}, {210, 70, 30}, {90, 0, 50}, {180, 90, 120},
		{0, 20, 40}, {30, 70, 200} },
		{ {70, 0, 20}, {100, 0, 100}, {255, 0, 0}, {255, 200, 0} },
		{ {40, 70, 10}, {40, 170, 10}, {100, 255, 70}, {255, 255, 255} },
		{ {0, 0, 0}, {0, 0, 255}, {0, 255, 255}, {255, 255, 255}, {0, 128, 255} },
		{ {0, 0, 0}, {255, 255, 255}, {128, 128, 128} },
	};
	private int pal = 0;
	private static final int[][] rows = {
		{ 0, 16,  8}, { 8, 16,  8}, 
		{ 4, 16,  4}, {12, 16,  4},
		{ 2, 16,  2}, {10, 16,  2}, 
		{ 6, 16,  2}, {14, 16,  2}, 
		{ 1, 16,  1}, { 9, 16,  1},
		{ 5, 16,  1}, {13, 16,  1},
		{ 3, 16,  1}, {11, 16,  1},
		{ 7, 16,  1}, {15, 16,  1}};

	private boolean smooth = true;
	private boolean antialias = true;
	private double viewX = 0.0;
	private double viewY = 0.0;
	private double zoom = 1.0;
	Thread improve = new Thread() {
		public void run() {
			while(true) {
]				if(current_max < absolute_max) current_max++;
				lastRender = System.currentTimeMillis();
				draw();
			}
		}
	};;

	
	public Mandelbrot(Revilo revilo) {
		super(revilo);
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	public Mandelbrot() {
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	
	public void draw() {
		BufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		Graphics g = newImage.getGraphics();

		// fractal image drawing
		for (int row = 0; row < rows.length; row++) {
			for (int y = rows[row][0]; y < height; y += rows[row][1]) {
				for (int x = 0; x < width; x++) {
					double r = zoom / Math.min(width, height);
					double dx = 2.5 * (x * r + viewX) - 2;
					double dy = 1.25 - 2.5 * (y * r + viewY);
					Color color = color(dx, dy);
					if (antialias) {
						Color c1 = color(dx - 0.25 * r, dy - 0.25 * r);
						Color c2 = color(dx + 0.25 * r, dy - 0.25 * r);
						Color c3 = color(dx + 0.25 * r, dy + 0.25 * r);
						Color c4 = color(dx - 0.25 * r, dy + 0.25 * r);
						int red = (color.getRed() + c1.getRed() + c2.getRed() + c3.getRed() + c4.getRed()) / 5;
						int green = (color.getGreen() + c1.getGreen() + c2.getGreen() + c3.getGreen() + c4.getGreen()) / 5;
						int blue = (color.getBlue() + c1.getBlue() + c2.getBlue() + c3.getBlue() + c4.getBlue()) / 5;
						color = new Color(red, green, blue);
					}
					g.setColor(color);
					g.fillRect(x, y - rows[row][2] / 2, 1, rows[row][2]);
				}
			}
		}
		g.dispose();
		image = newImage;
	}
	
	public void update() {
		current_max = default_max;
		lastRender = System.currentTimeMillis();
		try {
			improve.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		draw();
	}
	
	public void zoomIn(double scale) {
		viewX += (double) zoom*(scale - 1)/2;
		viewY += (double) zoom*(scale - 1)/2;
		zoom /= scale;
		
		update();
	}
	public void zoomOut(double scale) {
		viewX -= (double) zoom*(scale - 1)/2;
		viewY -= (double) zoom*(scale - 1)/2;
		zoom *= scale;
		update();
	}

	public void dragTo(int x, int y) {
		int dx = Math.abs(x - mouseX);
		int dy = Math.abs(y - mouseY);
		if(dx == 0 || dy == 0) return;
		double scale;
		if(dx < dy) scale = width / dx;
		else scale = height / dy;
		
		viewX += 2*zoom*mouseX/width;
		viewY += zoom*mouseY/height;
		
		zoom /= scale;
		update();
	}
	public void newPallette() {
		pal = (pal + 1) % colpal.length;
		update();
	}
	public void reset() {
		viewX = 0;
		viewY = 0;
		zoom = 1.0;
		update();
	}
	
	// Computes a colour for a given point
	private Color color(double x, double y) {
		int count = mandel(x, y);
		int palSize = colors[pal].length;
		Color color = colors[pal][count / 256 % palSize];
		if (smooth) {
			Color color2 = colors[pal][(count / 256 + palSize - 1) % palSize];
			int k1 = count % 256;
			int k2 = 255 - k1;
			int red = (k1 * color.getRed() + k2 * color2.getRed()) / 255;
			int green = (k1 * color.getGreen() + k2 * color2.getGreen()) / 255;
			int blue = (k1 * color.getBlue() + k2 * color2.getBlue()) / 255;
			color = new Color(red, green, blue);
		}
		return color;
	}
	
	private int mandel(double pRe, double pIm) {
		double zRe = 0;
		double zIm = 0;
		double zRe2 = zRe * zRe;
		double zIm2 = zIm * zIm;
		double zM2 = 0.0;
		int count = 0;
		int max = (int) Math.pow(2, current_max);
		while (zRe2 + zIm2 < 4.0 && count < max) {
			zM2 = zRe2 + zIm2;
			zIm = 2.0 * zRe * zIm + pIm;
			zRe = zRe2 - zIm2 + pRe;
			zRe2 = zRe * zRe;
			zIm2 = zIm * zIm;
			count++;
		}
		if (count == 0 || count == max) return 0;
		// transition smoothing
		zM2 += 0.000000001;
		return 256 * count + (int)(255.0 * Math.log(4 / zM2) / Math.log((zRe2 + zIm2) / zM2));
	}

	@Override
	public void leftClick(int x, int y) {
		//do nothing
	}

	@Override
	public void rightClick(int x, int y) {
		reset();
	}

	@Override
	protected void tick() {
		long timeSinceLastRender = System.currentTimeMillis() - lastRender;
		if(timeSinceLastRender > 4000) {
			improve.run();
		}
	}

	@Override
	protected void render() {
		BufferStrategy bs = this.getBufferStrategy();
		if(bs == null){
			this.createBufferStrategy(3);
			return;
		}
		
		Graphics g1 = bs.getDrawGraphics();
		Graphics2D g = (Graphics2D) g1;
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, // Anti-alias!
		        RenderingHints.VALUE_ANTIALIAS_ON);
		g.setColor(Color.black);
		if(image == null) g.fillRect(0, 0, width, height);
		else g.drawImage(image, null, 0, 0);
		
		if(dragging) {
			g.setColor(Color.white);
			double dx = Math.abs(dragX - mouseX);
			double dy = Math.abs(dragY - mouseY);
			if(dx != 0 && dy != 0) {
				double scale;
				if(dx < dy) scale = width / dx;
				else scale = height / dy;
				g.drawRect(mouseX, mouseY, (int) Math.round(width/scale), (int) Math.round(height/scale));
			}
		}
		g.dispose();
		bs.show();
	}
	
	@Override
	public void resize() {
		width = this.getWidth();
		height = this.getHeight();
		update();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-09-04 11:26:37.369
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-09-04 11:26:37.370
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-09-04 11:26:39.380
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cass.oli.mandelbrot;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;

import cass.oli.revilo.Game;
import cass.oli.revilo.Revilo;

public class Mandelbrot extends Game {
	private static final long serialVersionUID = 1L;
	private BufferedImage image = null;
	/**
	 * see http://java.rubikscube.info/
	 */
	private final int default_max = 6;
	private final int absolute_max = 12;
	private int current_max = 6;
	private Color[][] colors;
	private long lastRender = 0;
	private static final int[][][] colpal = {
		{ {0, 10, 20}, {50, 100, 240}, {20, 3, 26}, {230, 60, 20},
		{25, 10, 9}, {230, 170, 0}, {20, 40, 10}, {0, 100, 0},
		{5, 10, 10}, {210, 70, 30}, {90, 0, 50}, {180, 90, 120},
		{0, 20, 40}, {30, 70, 200} },
		{ {70, 0, 20}, {100, 0, 100}, {255, 0, 0}, {255, 200, 0} },
		{ {40, 70, 10}, {40, 170, 10}, {100, 255, 70}, {255, 255, 255} },
		{ {0, 0, 0}, {0, 0, 255}, {0, 255, 255}, {255, 255, 255}, {0, 128, 255} },
		{ {0, 0, 0}, {255, 255, 255}, {128, 128, 128} },
	};
	private int pal = 0;
	private static final int[][] rows = {
		{ 0, 16,  8}, { 8, 16,  8}, 
		{ 4, 16,  4}, {12, 16,  4},
		{ 2, 16,  2}, {10, 16,  2}, 
		{ 6, 16,  2}, {14, 16,  2}, 
		{ 1, 16,  1}, { 9, 16,  1},
		{ 5, 16,  1}, {13, 16,  1},
		{ 3, 16,  1}, {11, 16,  1},
		{ 7, 16,  1}, {15, 16,  1}};

	private boolean smooth = true;
	private boolean antialias = true;
	private double viewX = 0.0;
	private double viewY = 0.0;
	private double zoom = 1.0;
	Thread improve = new Thread() {
		public void run() {
			while(true) {
]				if(current_max < absolute_max) {
	current_max++;
}
				lastRender = System.currentTimeMillis();
				draw();
			}
		}
	};;

	
	public Mandelbrot(Revilo revilo) {
		super(revilo);
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	public Mandelbrot() {
		this.setSize(WIDTH, HEIGHT);
		lastRender = System.currentTimeMillis();
		colors = new Color[colpal.length][];
		for (int p = 0; p < colpal.length; p++) {
			colors[p] = new Color[colpal[p].length * 12];
			for (int i = 0; i < colpal[p].length; i++) {
				int[] c1 = colpal[p][i];
				int[] c2 = colpal[p][(i + 1) % colpal[p].length];
				for (int j = 0; j < 12; j++)
					colors[p][i * 12 + j] = new Color(
							(c1[0] * (11 - j) + c2[0] * j) / 11,
							(c1[1] * (11 - j) + c2[1] * j) / 11,
							(c1[2] * (11 - j) + c2[2] * j) / 11);
			}
		}
	}
	
	public void draw() {
		BufferedImage newImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		Graphics g = newImage.getGraphics();

		// fractal image drawing
		for (int row = 0; row < rows.length; row++) {
			for (int y = rows[row][0]; y < height; y += rows[row][1]) {
				for (int x = 0; x < width; x++) {
					double r = zoom / Math.min(width, height);
					double dx = 2.5 * (x * r + viewX) - 2;
					double dy = 1.25 - 2.5 * (y * r + viewY);
					Color color = color(dx, dy);
					if (antialias) {
						Color c1 = color(dx - 0.25 * r, dy - 0.25 * r);
						Color c2 = color(dx + 0.25 * r, dy - 0.25 * r);
						Color c3 = color(dx + 0.25 * r, dy + 0.25 * r);
						Color c4 = color(dx - 0.25 * r, dy + 0.25 * r);
						int red = (color.getRed() + c1.getRed() + c2.getRed() + c3.getRed() + c4.getRed()) / 5;
						int green = (color.getGreen() + c1.getGreen() + c2.getGreen() + c3.getGreen() + c4.getGreen()) / 5;
						int blue = (color.getBlue() + c1.getBlue() + c2.getBlue() + c3.getBlue() + c4.getBlue()) / 5;
						color = new Color(red, green, blue);
					}
					g.setColor(color);
					g.fillRect(x, y - rows[row][2] / 2, 1, rows[row][2]);
				}
			}
		}
		g.dispose();
		image = newImage;
	}
	
	public void update() {
		current_max = default_max;
		lastRender = System.currentTimeMillis();
		try {
			improve.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		draw();
	}
	
	public void zoomIn(double scale) {
		viewX += (double) zoom*(scale - 1)/2;
		viewY += (double) zoom*(scale - 1)/2;
		zoom /= scale;
		
		update();
	}
	public void zoomOut(double scale) {
		viewX -= (double) zoom*(scale - 1)/2;
		viewY -= (double) zoom*(scale - 1)/2;
		zoom *= scale;
		update();
	}

	public void dragTo(int x, int y) {
		int dx = Math.abs(x - mouseX);
		int dy = Math.abs(y - mouseY);
		if(dx == 0 || dy == 0) return;
		double scale;
		if(dx < dy) scale = width / dx;
		else scale = height / dy;
		
		viewX += 2*zoom*mouseX/width;
		viewY += zoom*mouseY/height;
		
		zoom /= scale;
		update();
	}
	public void newPallette() {
		pal = (pal + 1) % colpal.length;
		update();
	}
	public void reset() {
		viewX = 0;
		viewY = 0;
		zoom = 1.0;
		update();
	}
	
	// Computes a colour for a given point
	private Color color(double x, double y) {
		int count = mandel(x, y);
		int palSize = colors[pal].length;
		Color color = colors[pal][count / 256 % palSize];
		if (smooth) {
			Color color2 = colors[pal][(count / 256 + palSize - 1) % palSize];
			int k1 = count % 256;
			int k2 = 255 - k1;
			int red = (k1 * color.getRed() + k2 * color2.getRed()) / 255;
			int green = (k1 * color.getGreen() + k2 * color2.getGreen()) / 255;
			int blue = (k1 * color.getBlue() + k2 * color2.getBlue()) / 255;
			color = new Color(red, green, blue);
		}
		return color;
	}
	
	private int mandel(double pRe, double pIm) {
		double zRe = 0;
		double zIm = 0;
		double zRe2 = zRe * zRe;
		double zIm2 = zIm * zIm;
		double zM2 = 0.0;
		int count = 0;
		int max = (int) Math.pow(2, current_max);
		while (zRe2 + zIm2 < 4.0 && count < max) {
			zM2 = zRe2 + zIm2;
			zIm = 2.0 * zRe * zIm + pIm;
			zRe = zRe2 - zIm2 + pRe;
			zRe2 = zRe * zRe;
			zIm2 = zIm * zIm;
			count++;
		}
		if (count == 0 || count == max) return 0;
		// transition smoothing
		zM2 += 0.000000001;
		return 256 * count + (int)(255.0 * Math.log(4 / zM2) / Math.log((zRe2 + zIm2) / zM2));
	}

	@Override
	public void leftClick(int x, int y) {
		//do nothing
	}

	@Override
	public void rightClick(int x, int y) {
		reset();
	}

	@Override
	protected void tick() {
		long timeSinceLastRender = System.currentTimeMillis() - lastRender;
		if(timeSinceLastRender > 4000) {
			improve.run();
		}
	}

	@Override
	protected void render() {
		BufferStrategy bs = this.getBufferStrategy();
		if(bs == null){
			this.createBufferStrategy(3);
			return;
		}
		
		Graphics g1 = bs.getDrawGraphics();
		Graphics2D g = (Graphics2D) g1;
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, // Anti-alias!
		        RenderingHints.VALUE_ANTIALIAS_ON);
		g.setColor(Color.black);
		if(image == null) g.fillRect(0, 0, width, height);
		else g.drawImage(image, null, 0, 0);
		
		if(dragging) {
			g.setColor(Color.white);
			double dx = Math.abs(dragX - mouseX);
			double dy = Math.abs(dragY - mouseY);
			if(dx != 0 && dy != 0) {
				double scale;
				if(dx < dy) scale = width / dx;
				else scale = height / dy;
				g.drawRect(mouseX, mouseY, (int) Math.round(width/scale), (int) Math.round(height/scale));
			}
		}
		g.dispose();
		bs.show();
	}
	
	@Override
	public void resize() {
		width = this.getWidth();
		height = this.getHeight();
		update();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-09-04 11:26:39.381
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-09-04 11:26:39.382
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3377)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:455)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:197)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2019-09-04 15:36:55.901
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cass.oli.revilo;

import java.awt.Canvas;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.util.ArrayList;

import javax.swing.JFrame;

import cass.oli.boids.Boids;
import cass.oli.mandelbrot.Mandelbrot;
import cass.oli.pong.Pong;

public class Revilo extends Canvas implements Runnable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	private JFrame frame;
	
	public static final int TARGET_FPS = 60;
	final long OPTIMAL_TIME = 1000000000 / TARGET_FPS;
	public static final int WIDTH = 1280, HEIGHT = 720;
	public int width = WIDTH, height = HEIGHT;
	public boolean running, paused;
	
	public Game game = null;
	public ArrayList<Game> games = new ArrayList<>();
	Mouse mouse;
	
	public Revilo() {
		games.add(new Home(this));
		games.add(new Pong(this));
		games.add(new Boids(this));
		games.add(new Mandelbrot(this));
		
		mouse = new Mouse(this);
		this.addMouseListener(mouse);
		this.addMouseMotionListener(mouse);
		
		frame = new JFrame("Revilo");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		frame.setResizable(true);
		
		frame.addComponentListener(new ComponentAdapter() 
		{  
	        public void componentResized(ComponentEvent evt) {
	        	resize();
	        }
		});
		setGame(games.get(0));
		
		frame.setResizable(true);
		frame.setExtendedState(java.awt.Frame.MAXIMIZED_BOTH);
		frame.setVisible(true);
		
		while(true) {
			int width = 0;
			int height = 0;
			if(this.game != null) {
				width = game.getWidth();
				height = game.getHeight();
				this.frame.remove(game);
			}
			this.game = nextGame;
			nextGame = null;
			frame.add(game);
			frame.pack();
			if(width != 0) game.resize();
			this.game.run();
		}
	}
	
	public void setGame(Game game) {
		if(this.game != null) this.game.running = false;
		this.nextGame = game;	
	}
	
	public void resize()

	public static void main(String[] args) {
		new Revilo();
	}
	
	public void run() {
		running = true;
		paused = false;
		stopped = false;
		while(running) {
			long lastTime = System.nanoTime();
			
			if(!paused) tick();
			try {
				render();
			} catch (Exception e1) {
				revilo.setGame(this);
			}
						
			long tick_time = (lastTime - System.nanoTime() + OPTIMAL_TIME)/1000000;
			if(tick_time > 0){
				try{
					Thread.sleep(tick_time);
				}catch(Exception e) {}
			}
		}
		stopped = true;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:644)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2019-09-04 15:36:56.112
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:644)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2019-09-04 15:36:56.117
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2970)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:644)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3114)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1438)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:391)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1145)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1322)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2019-09-04 16:07:21.310 -----------------------------------------------
eclipse.buildId=4.12.0.I20190605-1800
java.version=12.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.core 1 0 2019-09-04 16:07:27.926
!MESSAGE Using Apache MINA sshd as ssh client.

!ENTRY org.eclipse.egit.ui 2 0 2019-09-04 16:07:43.232
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\olica'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
